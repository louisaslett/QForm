#' Bounds on the CDF of a Quadratic Form in Gaussians
#'
#' Returns upper and lower bounds on the CDF for random variables \eqn{Q_f = T_f + R_f} where \deqn{T_f = \sum\limits_{i \in \mathcal{T}} f\left(\eta_i \right) \left(Z_i + \delta_i)^2, \ \ \ \ R_f = \sum\limits_{i \in \mathcal{R}} f\left(\eta_i \right) \left(Z_i + \delta_i)^2}{T_f = \Sigma_{i \in T} f (\eta_i) (Z_i + \delta_i)^2,     R_f = \Sigma_{i \in R} f (\eta_i) (Z_i + \delta_i)^2,} \eqn{Z_i \sim N(0,1)}{Z_i ~ N(0,1)}, and only the CDF of \eqn{T_f} is known.
#'
#' Currently only \eqn{f = "identity"} is supported, but future versions will allow one to select \eqn{f} from a list or specify their own function with it's corresponding bounds through a QFormFunction object.
#'
#' For a given input \code{q}, the returned function outputs a vector with the lower bound on the CDF at \code{q} as the first entry; the upper bound, as the second.  If \code{q} is not known exactly, but only a lower bound \code{ql} and an upper bound \code{qu} are known, then those may provided instead of \code{q} and the returned bounds on the CDF will be valid for an \code{q} in \code{[ql,qu]}.  If \code{q} is provided, \code{ql} and \code{qu} are ignored.
#'
#' The returned function has two optional, logical arguments.  \code{lower.tail} returns 1 minus the bounds when \code{TRUE} (not used if \code{density}==TRUE) and is highly recommended for those interested in the upper tail of \eqn{Q_f}.  \code{log.p} returns the desired bounds in log space.
#'
#' @param cdf function; the cdf of \eqn{T_f} returned by \code{QForm::QForm}
#' @param f character or QFormFunction object; the function \eqn{f} for the \eqn{Q_f} of interest.
#' @param max.abs.eta vector; element-wise upper bound on the absolute value of the \eqn{\eta_i} in \eqn{R_f} (see Details)
#' @param sum.eta vector; element-wise sum of the \eqn{\eta_i} in \eqn{R_f} (see Details)
#' @param sum.etasq vector; element-wise sum of the \eqn{\eta^2_i} in \eqn{R_f} (see Details)
#' @param sum.eta.deltasq vector; element-wise sum of the \eqn{\eta_i \delta^2_i} in \eqn{R_f} (see Details)
#' @param sum.etasq.deltasq vector; element-wise sum of the \eqn{\eta^2_i \delta^2_i} in \eqn{R_f} (see Details)
#'
#' @return A non-vectorized function which evaluates upper and lower bounds on the CDF of \eqn{Q_f}.
#'
#' @examples
#'
#' f.eta <- c(-12, -7, 5, 7, -9, 10, 8)
#' delta <- c(2, 10, -4, 3, 8, -5, -12)
#'
#' cdf <- QFGauss(f.eta, delta)
#'
#' bounds <- QFGaussBounds(cdf = cdf, f = "identity",
#'                         max.abs.eta = 10, sum.eta = 5, sum.etasq = 200)
#'
#' xx <- seq(-1e3, 1e3, len = 6)
#' ## This may take 5 - 10 secs.
#' y <- as.data.frame(t(mapply(bounds, ql = xx-1, qu = xx+1)))
#'
#' x <- seq(-1e3, 1e3, len = 1e3)
#' plot(x, cdf(x), type = "l")
#'
#' points(xx, y$lower, col = "blue")
#' points(xx, y$upper, col = "red")
#'
#' @export

QFGaussBounds <- function(cdf, f = "identity", max.abs.eta, sum.eta, sum.etasq, sum.eta.deltasq = 0, sum.etasq.deltasq = 0) {

  if(max.abs.eta <= 0){stop("max.eta must be positive")}

  # This function takes a cdf generated by QFcdf and a function f with it's associated arguments and returns
  # a function that returns bounds

  # Create set of integration functions needed for integrating over the extrapolated tails of cdf corresponding to
  # the concentration bound for f
  if(f == "identity"){
    conc.ineqs <- WrapConcIneq.identity(sum.eta.deltasq + sum.eta, sum.eta.deltasq + sum.eta, 8*sum.etasq.deltasq + 4*sum.etasq, 1/(4*max.abs.eta))
  }else{
    stop("For now, identity is the only valid option for f")
  }


  # Import tail features from the tail.features attribute of cdf
  tf <- attr(cdf,"tail.features")
  lambda.signs <- tf$lambda.signs
  ep.l <- tf$extrapolation.point.l
  ep.r <- tf$extrapolation.point.r
  a.l <- tf$a.l
  b.l <- tf$b.l
  a.r <- tf$a.r
  b.r <- tf$b.r

  # Create bounding function
  function(q = NULL, ql = NULL, qu = NULL, lower.tail = TRUE, log.p = FALSE){

    # if q is specified it overrides q.l and q.u
    if(any(length(q),length(ql),length(qu))>1){stop("q, q.l, and q.u cannot have length > 1")}

    # If q is specified, it over-rides qu and ql.
    if(!is.null(q)){
      if(!is.numeric(q)){stop("q must be numeric")}
      qu <- ql <- q
    }else{
      if( !(is.numeric(ql) & is.numeric(qu))  ){stop("ql and qu must be numeric")}
    }

    # Initialize
    upper.components <- lower.components <- rep(0,5)

    ### Compute Upper Bound

    upper.components[1] <- (1-conc.ineqs$l(-conc.ineqs$c2))*cdf(qu)

    if(qu < ep.l){

      if(lambda.signs=="mixed"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[2] <- conc.ineqs$int.h2.explogx(max(qu,0),ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(ep.l, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((qu >= ep.l) & (qu < ep.r)){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(qu,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from qu to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(qu, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from qu to t.cdf$x[n]

    }

    if(qu >= ep.r){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(qu,0,qu,a.r,b.r)
      }

    }

    if(lower.tail){
      upper.bound <- sum(upper.components)
    }else{
      upper.bound <- sum(1,-upper.components[1:4])-upper.components[5]
    }


    ### Compute Lower Bound

    lower.components[1] <- (1-conc.ineqs$u(-conc.ineqs$c1))*cdf(ql)

    if(ql > ep.r){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql,ql,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql,ql,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql) # This integrates out to ql instead of min(ql,0) because we need to account for the constant plateau of the NSD density above 0
        lower.components[5] <- -conc.ineqs$int.h1.explognegx(ep.r,min(0,ql),ql,a.r,b.r)
      }

      #lower.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ep.r, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((ql > ep.l) & (ql <= ep.r)){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }

      #lower.components[3] <- boole(ql,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y,int.to.right = F) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ql, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to ql
    }

    if(ql <= ep.l){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ql,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql,ql,a.l,b.l)
      }

    }

    if(lower.tail){
      lower.bound <- sum(lower.components)
    }else{
      lower.bound <- sum(1,-lower.components[1:4])-lower.components[5]
    }

    # Use these print functions here for debugging contributions from different components
    #print(c(qu,upper.components))
    #print(c(ql,lower.components))

    # Make sure the results fall within [0,1]

    if(lower.bound < 0){lower.bound <- 0}
    if(lower.bound > 1){lower.bound <- 1}

    if(upper.bound < 0){upper.bound <- 0}
    if(upper.bound > 1){upper.bound <- 1}


    if(log.p){
      ans <- log(c(lower.bound,upper.bound))
    }else{
      ans <- c(lower.bound,upper.bound)
    }
    names(ans) <- c("lower.bound","upper.bound")
    ans
  }

}

#' New Bounds on the CDF of a Quadratic Form in Gaussians
#' @export
QFGaussBoundsNew <- function(cdf, f = "identity", max.abs.eta, sum.eta, sum.etasq, sum.eta.deltasq = 0, sum.etasq.deltasq = 0) {

  if(max.abs.eta <= 0){stop("max.eta must be positive")}

  # This function takes a cdf generated by QFcdf and a function f with it's associated arguments and returns
  # a function that returns bounds

  # Create set of integration functions needed for integrating over the extrapolated tails of cdf corresponding to
  # the concentration bound for f
  if(f == "identity"){
    conc.ineqs <- WrapConcIneq.identity(sum.eta.deltasq + sum.eta, sum.eta.deltasq + sum.eta, 8*sum.etasq.deltasq + 4*sum.etasq, 1/(4*max.abs.eta))
  }else{
    stop("For now, identity is the only valid option for f")
  }


  # Import tail features from the tail.features attribute of cdf
  tf <- attr(cdf,"tail.features")
  lambda.signs <- tf$lambda.signs
  ep.l <- tf$extrapolation.point.l
  ep.r <- tf$extrapolation.point.r
  a.l <- tf$a.l
  b.l <- tf$b.l
  a.r <- tf$a.r
  b.r <- tf$b.r

  # Create bounding function
  function(q = NULL, ql = NULL, qu = NULL, lower.tail = TRUE, log.p = FALSE){

    # if q is specified it overrides q.l and q.u
    if(any(length(q),length(ql),length(qu))>1){stop("q, q.l, and q.u cannot have length > 1")}

    # If q is specified, it over-rides qu and ql.
    if(!is.null(q)){
      if(!is.numeric(q)){stop("q must be numeric")}
      qu <- ql <- q
    }else{
      if( !(is.numeric(ql) & is.numeric(qu))  ){stop("ql and qu must be numeric")}
    }

    # Initialize
    upper.components <- lower.components <- rep(0,5)

    ### Compute Upper Bound

    upper.components[1] <- (1-conc.ineqs$l(0))*cdf(qu-conc.ineqs$c2)

    if(qu-conc.ineqs$c2 < ep.l){

      if(lambda.signs=="mixed"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu-conc.ineqs$c2,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[2] <- conc.ineqs$int.h2.explogx(max(qu-conc.ineqs$c2,0),ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu-conc.ineqs$c2,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(ep.l, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((qu-conc.ineqs$c2 >= ep.l) & (qu-conc.ineqs$c2 < ep.r)){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(qu,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from qu to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(qu-conc.ineqs$c2, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from qu to t.cdf$x[n]

    }

    if(qu-conc.ineqs$c2 >= ep.r){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu-conc.ineqs$c2,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu-conc.ineqs$c2,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu-conc.ineqs$c2,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu-conc.ineqs$c2,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu-conc.ineqs$c2,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(qu-conc.ineqs$c2,0,qu,a.r,b.r)
      }

    }

    if(lower.tail){
      upper.bound <- sum(upper.components)
    }else{
      upper.bound <- sum(1,-upper.components[1:4])-upper.components[5]
    }


    ### Compute Lower Bound

    lower.components[1] <- (1-conc.ineqs$u(0))*cdf(ql-conc.ineqs$c1)

    if(ql-conc.ineqs$c1 > ep.r){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql-conc.ineqs$c1,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql-conc.ineqs$c1,ql,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql-conc.ineqs$c1,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql-conc.ineqs$c1,ql,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql-conc.ineqs$c1,ql) # This integrates out to ql instead of min(ql,0) because we need to account for the constant plateau of the NSD density above 0
        lower.components[5] <- -conc.ineqs$int.h1.explognegx(ep.r,min(0,ql-conc.ineqs$c1),ql,a.r,b.r)
      }

      #lower.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ep.r, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((ql-conc.ineqs$c1 > ep.l) & (ql-conc.ineqs$c1 <= ep.r)){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }

      #lower.components[3] <- boole(ql,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y,int.to.right = F) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ql-conc.ineqs$c1, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to ql
    }

    if(ql-conc.ineqs$c1 <= ep.l){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql-conc.ineqs$c1,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ql-conc.ineqs$c1,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql-conc.ineqs$c1,ql,a.l,b.l)
      }

    }

    if(lower.tail){
      lower.bound <- sum(lower.components)
    }else{
      lower.bound <- sum(1,-lower.components[1:4])-lower.components[5]
    }

    # Use these print functions here for debugging contributions from different components
    #print(c(qu,upper.components))
    #print(c(ql,lower.components))

    # Make sure the results fall within [0,1]

    if(lower.bound < 0){lower.bound <- 0}
    if(lower.bound > 1){lower.bound <- 1}

    if(upper.bound < 0){upper.bound <- 0}
    if(upper.bound > 1){upper.bound <- 1}


    if(log.p){
      ans <- log(c(lower.bound,upper.bound))
    }else{
      ans <- c(lower.bound,upper.bound)
    }
    names(ans) <- c("lower.bound","upper.bound")
    ans
  }

}


