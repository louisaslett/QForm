#' Quadratic Form Bounds
#'
#' Compute upper and lower bounds on the CDF of a quadratic form in normal random variables.
#'
#' Gory details....
#'
#' @param obs vector; observed values of the quadratic form for which upper and lower bounds on the CDF
#' @param qf.cdf QForm cdf object; output of QFcdf for some set of coefficients and ncps
#' @param fun character string; function to be applied to coefficients.  Current options: "identity","power","exponential"
#' @param fun.args list; list of function arguments required for the corresponding function type provided in fun
#' @param lower.tail logical; if \code{TRUE} (default), probability is \eqn{P(y^T M y \le obs)}, otherwise \eqn{P(y^T M y > obs)}
#' @param log logical; if \code{TRUE}, probability \eqn{p} is given as \eqn{log(p)}
#'
#' @return A data frame containing the variables lower and upper which provide the bounds on the CDF of the quadratic form.
#'
#' @examples
#' # Some code here which runs a self-contained example
#'

QBounds <- function(cdf, f = "identity", bound.args=list("Er" = 0, "nu" = 1 , "L" = 1)) {

  # This function takes a cdf generated by QFcdf and a function f with it's associated arguments and returns
  # a function that returns bounds


  # Create set of integration functions needed for integrating over the extrapolated tails of cdf corresponding to
  # the concentration bound for f
  if(f == "identity"){
    conc.ineqs <- WrapConcIneq.identity(bound.args$Er,bound.args$Er,bound.args$nu,bound.args$L)
  }else{
    stop("For now, identity is the only valid option for f")
  }


  # Import tail features from the tail.features attribute of cdf
  tf <- attr(cdf,"tail.features")
  lambda.signs <- tf$lambda.signs
  ep.l <- tf$extrapolation.point.l
  ep.r <- tf$extrapolation.point.r
  a.l <- tf$a.l
  b.l <- tf$b.l
  a.r <- tf$a.r
  b.r <- tf$b.r

  # Create bounding function
  cdf.bounds <- function(ql, qu = NULL, lower.tail = TRUE, log.p = FALSE){

    if(is.null(qu)){qu <- ql}

    # Initialize
    upper.components <- lower.components <- rep(0,5)

    ### Compute Upper Bound

    upper.components[1] <- (1-conc.ineqs$l(-conc.ineqs$c2))*cdf(qu)

    if(qu < ep.l){

      if(lambda.signs=="mixed"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[2] <- conc.ineqs$int.h2.explogx(max(qu,0),ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(ep.l, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((qu >= ep.l) & (qu < ep.r)){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(qu,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from qu to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(qu, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from qu to t.cdf$x[n]

    }

    if(qu >= ep.r){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(qu,0,qu,a.r,b.r)
      }

    }

    if(lower.tail){
      upper.bound <- sum(upper.components)
    }else{
      upper.bound <- sum(1,-upper.components[1:4])-upper.components[5]
    }


    ### Compute Lower Bound

    lower.components[1] <- (1-conc.ineqs$u(-conc.ineqs$c1))*cdf(ql)

    if(ql > ep.r){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql,ql,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql,ql,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql) # This integrates out to ql instead of min(ql,0) because we need to account for the constant plateau of the NSD density above 0
        lower.components[5] <- -conc.ineqs$int.h1.explognegx(ep.r,min(0,ql),ql,a.r,b.r)
      }

      #lower.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ep.r, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((ql > ep.l) & (ql <= ep.r)){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }

      #lower.components[3] <- boole(ql,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y,int.to.right = F) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ql, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to ql
    }

    if(ql <= ep.l){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ql,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql,ql,a.l,b.l)
      }

    }

    if(lower.tail){
      lower.bound <- sum(lower.components)
    }else{
      lower.bound <- sum(1,-lower.components[1:4])-lower.components[5]
    }

    # Use these print functions here for debugging contributions from different components
    #print(c(qu,upper.components))
    #print(c(ql,lower.components))

    # Make sure the results fall within [0,1]

    if(lower.bound < 0){lower.bound <- 0}
    if(lower.bound > 1){lower.bound <- 1}

    if(upper.bound < 0){upper.bound <- 0}
    if(upper.bound > 1){upper.bound <- 1}


    if(log.p){
      ans <- log(c(lower.bound,upper.bound))
    }else{
      ans <- c(lower.bound,upper.bound)
    }
    ans
  }

  # Return vectorized version of bounding function
  Vectorize(cdf.bounds,vectorize.args = c("ql","qu"))
}


# Declare Header Functions
G1<-function(from,to,b){

  n1 <- length(from)
  n2 <- length(to)
  if(n1>1 & n2>1){stop("either from or to may be vectors but not both at the same time")}
  n <- max(n1,n2)

  # This performs the integral $ \int_\from^\to exp(-b*z) dz $ for any sign of b.
  #if(any(to<from)){warning("some to > from, so for those values returning -Inf")}
  if(any(is.infinite(from) & is.infinite(to))){stop("both from and psi cannot be infinite")}
  if(any(is.infinite(from) & from > 0)){stop("from cannot be positive infinity")}
  if(any(is.infinite(to) & to < 0)){stop("from cannot be negative infinity")}
  if(any(is.infinite(from)) & b > 0){stop("b cannot be positive when from is negative infinity --> integral does not converge")}
  if(any(is.infinite(to)) & b < 0){stop("b cannot be negative when to is infinity --> integral does not converge")}

  ifelse(to<=from, -Inf, ifelse(rep(b,n)==0,-a+log(to-from),-log(abs(b))+log(-expm1(-abs(b)*(to-from)))-b*ifelse(rep(b,n)>0,from,to)))
}
#G1 is correct
#print(-G1(-20:-10,Inf,2)/log(10),digits=22)
#print(-log(integrate(f=function(z,b){exp(-b*z)},lower =-20,upper = Inf,b=2)$value)/log(10),digits=22)


G2 <- function(from, to, b, L){
  # This function performs Gauss Quadrature if L < 0.
  # either from or to may be vectors but not both simultaneously
  #if(any(to<from)){warning("some to > from, so for those values returning -Inf")}
  if(b>=1){stop("b must be < 1")}

  n1 <- length(to)
  n2 <- length(from)
  n <- max(n1,n2)
  ifelse(to<=from,-Inf,ifelse(rep(L,n)<0,
                              Vectorize(function(from,to,b,L){log(integrate(f=function(z,b,L){z^(-b)*exp(-L*z)},lower = from,upper = to,b=b,L=L)$value)},vectorize.args = c("from","to"))(from, to, b, L)
                              ,-(1-b)*log(L)+pgamma(L*to,1-b,log.p = T)+lgamma(1-b) + (from >0)*log(-expm1(pgamma(L*from,1-b,log.p = T)- pgamma(L*to,1-b,log.p = T)))))
}
#G2 is correct
# print(G2(0,c(0.1,0.2),-3,-10),digits=22)
# print(log(integrate(f=function(z,b,L){z^(-b)*exp(-L*z)},lower = 0,upper = 0.2,b=-3,L=-10)$value),digits=22)



G3 <- function(from, to, mu, nu ){
  if(nu<=0){stop("nu must be > 0")}
  #if(any(to<from)){warning("some to > from, so for those values returning -Inf")}
  s<-sqrt(nu)
  from.tilde <- (from - mu)/s
  to.tilde <- (to - mu)/s
  ifelse(to<=from,-Inf,0.5*log(2*pi*nu) + pnorm(to.tilde,log.p = T) + log(-expm1(pnorm(from.tilde,log.p = T)-pnorm(to.tilde,log.p = T))))
}
# #G3 is correct
#print(exp(G3(lower.prime,upper.prime,q-c2-b*nu,nu)),digits=22)
#print(integrate(f=function(z,mu,nu){exp(-0.5*(z-mu)^2/nu)},lower = lower.prime,upper = upper.prime,mu=q-c2-b*nu,nu=nu,rel.tol = 1e-13)$value,digits=22)
# print(exp(G3(-20,-10,0,.1)),digits=22)
# print(integrate(f=function(z,mu,nu){exp(-0.5*(z-mu)^2/nu)},lower = -20,upper = -10,mu=0,nu=.1,rel.tol = 1e-13)$value,digits=22)
#


G4 <- function(from, to, mu, nu ){
  if(nu<=0){stop("nu must be > 0")}
  #if(any(to<from)){warning("some to > from, so for those values returning -Inf")}
  s<-sqrt(nu)
  from.tilde <- (from - mu)/s
  to.tilde <- (to - mu)/s
  ifelse(to<=from,-Inf,0.5*log(2*pi*nu) + log( s*(dnorm(from.tilde)-dnorm(to.tilde))
                                               + mu*(pnorm(to.tilde)-pnorm(from.tilde))
  ))
}
# #G4 is correct
#print(exp(G4(lower.prime,upper.prime,q-c2-b*nu,nu)),digits=22)
#print(integrate(f=function(z,mu,nu){z*exp(-0.5*(z-mu)^2/nu)},lower = lower.prime,upper = upper.prime,mu=q-c2-b*nu,nu=nu,rel.tol = 1e-13)$value,digits=22)

# print(exp(G4(20,30,0,1)),digits=22)
# print(integrate(f=function(z,mu,nu){z*exp(-0.5*(z-mu)^2/nu)},lower = 20,upper = 30,mu=0,nu=1,rel.tol = 1e-13)$value,digits=22)

expG4 <- function(from, to, mu, nu ){
  if(nu<=0){stop("nu must be > 0")}
  #if(any(to<from)){warning("some to > from, so for those values returning -Inf")}
  s<-sqrt(nu)
  from.tilde <- (from - mu)/s
  to.tilde <- (to - mu)/s
  ifelse(to<=from,0,sqrt(2*pi*nu)*( s*(dnorm(from.tilde)-dnorm(to.tilde))
                                    + mu*(pnorm(to.tilde)-pnorm(from.tilde))
  ))
}


G5 <- function(from, to, b, nu ){
  if(any(from<0)){stop("from must be >= 0")}
  if(any(to<from)){warning("some to > from, so for those values returning -Inf")}
  if(b>=2){stop("b must be < 2")}
  ifelse(to<=from,-Inf,-log(2) + G2(from^2,to^2,b/2,1/(2*nu)))
}
# #G5 is correct
# print(exp(G5(-5,0:10,-2,2)),digits=22)
# print(integrate(f=function(z,b,nu){z^(1-b)*exp(-0.5*z^2/nu)},lower = 1,upper = 4,b=-20,nu=.02)$value,digits=22)

WrapConcIneq.identity <- function(c1,c2,nu,L){

  if(!all(is.numeric(c(c1,c2,nu,L)))){
    stop("c1,c2, nu, and L must all be numeric")
  }
  if(nu<=0){
    stop("nu must be positive")
  }
  if(L<=0){
    stop("L must be positive")
  }


  u = function(x) ifelse(x<0,1,ifelse(x < nu*L, exp(-0.5*(x^2)/nu), exp(0.5*nu*L^2-L*x)))
  l = function(x) ifelse(x>0,1,ifelse(x > -nu*L, exp(-0.5*(x^2)/nu), exp(0.5*nu*L^2+L*x)))

  list(
    "L" = L,
    "nu" = nu,
    "u" = u,
    "l" = l,
    "c1" = c1,
    "h1" = function(q,t){
      ifelse(t >= q-c1, 0 , ifelse(t > q-c1-nu*L, (q-c1-t)*exp(-0.5*((q-c1-t)^2)/nu)/nu,L*exp(0.5*nu*L^2-(q-c1)*L+L*t)))
    },
    "int.h1.const" = function(lower, upper, q){
      if(lower>=upper){return(0)}
      u(q-c1-upper) - u(q-c1-lower)
    },
    "int.h1.expx" = function(lower, upper, q, a, b){
      if(lower>=upper){return(0)}
      lower.prime <- pmax(lower,q-c1-nu*L)
      upper.prime <- pmin(upper,q-c1)
      upper.prime.prime <- pmin(upper,q-c1-nu*L)

      (lower.prime < upper.prime)*max(min(exp((nu*b^2)/2 - b*(q-c1)-a),.Machine$double.xmax),.Machine$double.xmin)*((q-c1)*exp(G3(lower.prime,upper.prime,q-c1-b*nu,nu))-expG4(lower.prime,upper.prime,q-c1-b*nu,nu))/nu + (lower < upper.prime.prime)*L*exp(0.5*nu*L^2-(q-c1)*L-a+G1(lower,upper.prime.prime,b-L))
    },
    "int.h1.explogx" = function(lower, upper, q, a, b){
      if(lower>=upper){return(0)}
      lower.prime <- pmax(lower,q-c1-nu*L)
      upper.prime <- pmin(upper,q-c1)
      upper.prime.prime <- pmin(upper,q-c1-nu*L)

      t.func <- function(t,q,c1,b,nu) { (q-c1-t)*t^(-b) * dnorm(t, mean = q-c1, sd = sqrt(nu)) }

      (lower.prime < upper.prime)*exp(-a)*sqrt(2*pi/nu)*Vectorize(function(f,lower,upper,q,c1,b,nu){integrate(f = f, lower = lower, upper = upper, q = q, c1 = c1, b = b, nu = nu)$value},vectorize.args = c("lower","upper"))(t.func, lower.prime, upper.prime, q, c1, b, nu)
      + (lower < upper.prime.prime)*L*exp(0.5*nu*L^2-(q-c1)*L-a+G2(lower, upper.prime.prime, b, -L))
    },
    "int.h1.explognegx" = function(lower, upper, q, a, b){
      if(lower>=upper){return(0)}
      lower.prime <- pmax(lower,q-c1-nu*L)
      upper.prime <- pmin(upper,q-c1)
      upper.prime.prime <- pmin(upper,q-c1-nu*L)

      z.func <- function(z,q,c1,b,nu) { (q-c1+z)*z^(-b) * dnorm(z, mean = q-c1, sd = sqrt(nu)) }

      (lower.prime < upper.prime)*exp(-a)*sqrt(2*pi/nu)*Vectorize(function(f,lower,upper,q,c1,b,nu){integrate(f = f, lower = lower, upper = upper, q = q, c1 = c1, b = b, nu = nu)$value},vectorize.args = c("lower","upper"))(z.func, -upper.prime, -lower.prime, q, c1, b, nu)
      + (lower < upper.prime.prime)*L*exp(0.5*nu*L^2-(q-c1)*L-a+G2(-upper.prime.prime,-lower, b, L))
    },
    "c2" = c2,
    "h2" = function(q,t){
      ifelse(t <= q-c2, 0 , ifelse(t < q-c2+nu*L, (c2-q+t)*exp(-0.5*((c2-q+t)^2)/nu)/nu,L*exp(0.5*nu*L^2-(c2-q)*L-L*t)))
    },
    "int.h2.const" = function(lower, upper, q){
      if(lower>=upper){return(0)}
      u(c2-q+lower) - u(c2-q+upper)
    },
    "int.h2.expx" = function(lower, upper, q, a, b){
      if(lower>=upper){return(0)}
      lower.prime <- pmax(lower,q-c2)
      upper.prime <- pmin(upper,q-c2+nu*L)
      lower.prime.prime <- pmax(lower,q-c2+nu*L)

      (lower.prime < upper.prime)*max(min(exp((nu*b^2)/2 - b*(q-c2)-a),.Machine$double.xmax),.Machine$double.xmin) *((c2-q)*exp(G3(lower.prime,upper.prime,q-c2-b*nu,nu))+expG4(lower.prime,upper.prime,q-c2-b*nu,nu))/nu + (lower.prime.prime < upper)*L*exp(0.5*nu*L^2+(q-c2)*L-a+G1(lower.prime.prime,upper,b+L))
    },
    "int.h2.explogx" = function(lower, upper, q, a, b){
      if(lower>=upper){return(0)}
      lower.prime <- pmax(lower,q-c2)
      upper.prime <- pmin(upper,q-c2+nu*L)
      lower.prime.prime <- pmax(lower,q-c2+nu*L)

      t.func <- function(t,q,c2,b,nu) { (c2-q+t)*t^(-b) * dnorm(t, mean = q-c2, sd = sqrt(nu)) }

      (lower.prime < upper.prime)*exp(-a)*sqrt(2*pi/nu)*Vectorize(function(f,lower,upper,q,c2,b,nu){integrate(f = f, lower = lower, upper = upper, q = q, c2 = c2, b = b, nu = nu)$value},vectorize.args = c("lower","upper"))(t.func, lower.prime, upper.prime, q, c2, b, nu)
      + (lower.prime.prime < upper)*L*exp(0.5*nu*L^2+(q-c2)*L-a+G2(lower.prime.prime, upper, b, L))
    },
    "int.h2.explognegx" = function(lower, upper, q, a, b){

      # lower <- t.cdf$x[t.cdf$n]
      # upper <- Inf
      # q <- -1000
      # a <- t.cdf$a.r
      # b <- t.cdf$b.r
      # c2 <- Er
      # nu <- conc.ineqs$nu
      # L <- conc.ineqs$L
      #
      if(lower>=upper){return(0)}
      lower.prime <- pmax(lower,q-c2)
      upper.prime <- pmin(upper,q-c2+nu*L)
      lower.prime.prime <- pmax(lower,q-c2+nu*L)

      z.func <- function(z,q,c2,b,nu) { (c2-q-z)*z^(-b) * dnorm(z, mean = c2-q, sd = sqrt(nu)) }

      (lower.prime < upper.prime)*exp(-a)*sqrt(2*pi/nu)*Vectorize(function(f,lower,upper,q,c2,b,nu){integrate(f = f, lower = lower, upper = upper, q = q, c2 = c2, b = b, nu = nu)$value},vectorize.args = c("lower","upper"))(z.func, -upper.prime, -lower.prime, q, c2, b, nu)
      + (lower.prime.prime < upper)*L*exp(0.5*nu*L^2-(c2-q)*L-a+G2(-upper,-lower.prime.prime, b, -L))
    }
  )
}

GaussQuadCDF<-function(from, to, lower.bound = T, cdf,ql,qu,conc.ineqs){

  # This function integrates the "body" of the CDF against a function h.
  # Since h has a given mode that we don't want the Gauss quadrature routine to miss, we divide the integral into two regions of
  # integration, one leading up to and one leading away from the mode of h so that the the mode of h is always an endpoint of
  # the integration region passed to integrate (ensuring that the mode is not missed)

  components <- rep(0,2)

  c1 <- conc.ineqs$c1
  c2 <- conc.ineqs$c2
  nu <- conc.ineqs$nu

  if(lower.bound){
    if(from < (ql-c1-sqrt(nu)))
      components[1] <- integrate( function(t,ql){conc.ineqs$h1(ql,t)*cdf(t)}, lower=from,upper=min(to,ql-c1-sqrt(nu)),ql=ql,rel.tol = 1e-10)$value
    if(to > (ql-c1-sqrt(nu)) & from < (ql-c1) ){
      components[2] <- integrate( function(t,ql){conc.ineqs$h1(ql,t)*cdf(t)}, lower=max(ql-c1-sqrt(nu),from),upper=min(to,ql-c1),ql=ql,rel.tol=1e-10)$value
    }
  }

  if(!lower.bound){

    if((from < (qu-c2+sqrt(nu))) & (to > qu-c2) ){
      components[1] <- integrate( function(t,qu){conc.ineqs$h2(qu,t)*cdf(t)}, lower=max(from,qu-c2),upper=min(to,qu-c2+sqrt(nu)),qu=qu,rel.tol = 1e-10)$value
    }
    if(to > (qu-c2+sqrt(nu)))
      components[2] <- integrate( function(t,qu){conc.ineqs$h2(qu,t)*cdf(t)}, lower=max(from,qu-c2+sqrt(nu)),upper=to,qu=qu,rel.tol = 1e-10)$value
  }

  sum(components)
}



