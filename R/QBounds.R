#'  Quadratic Form Bounds
#'
#' Compute upper and lower bounds on the CDF of a quadratic form in normal random variables.
#'
#' Gory details....
#'
#' @param obs vector; observed values of the quadratic form for which upper and lower bounds on the CDF
#' @param qf.cdf QForm cdf object; output of QFcdf for some set of coefficients and ncps
#' @param fun character string; function to be applied to coefficients.  Current options: "identity","power","exponential"
#' @param fun.args list; list of function arguments required for the corresponding function type provided in fun
#' @param lower.tail logical; if \code{TRUE} (default), probability is \eqn{P(y^T M y \le obs)}, otherwise \eqn{P(y^T M y > obs)}
#' @param log logical; if \code{TRUE}, probability \eqn{p} is given as \eqn{log(p)}
#'
#' @return A data frame containing the variables lower and upper which provide the bounds on the CDF of the quadratic form.
#'
#' @examples
#' # Some code here which runs a self-contained example
#'
#' @export

QBounds <- function(cdf, f = "identity", bound.args=list("Er" = 0, "nu" = 1 , "L" = 1)) {

  # This function takes a cdf generated by QFcdf and a function f with it's associated arguments and returns
  # a function that returns bounds


  # Create set of integration functions needed for integrating over the extrapolated tails of cdf corresponding to
  # the concentration bound for f
  if(f == "identity"){
    conc.ineqs <- WrapConcIneq.identity(bound.args$Er,bound.args$Er,bound.args$nu,bound.args$L)
  }else{
    stop("For now, identity is the only valid option for f")
  }


  # Import tail features from the tail.features attribute of cdf
  tf <- attr(cdf,"tail.features")
  lambda.signs <- tf$lambda.signs
  ep.l <- tf$extrapolation.point.l
  ep.r <- tf$extrapolation.point.r
  a.l <- tf$a.l
  b.l <- tf$b.l
  a.r <- tf$a.r
  b.r <- tf$b.r

  # Create bounding function
  cdf.bounds <- function(ql, qu = NULL, lower.tail = TRUE, log.p = FALSE){

    if(is.null(qu)){qu <- ql}

    # Initialize
    upper.components <- lower.components <- rep(0,5)

    ### Compute Upper Bound

    upper.components[1] <- (1-conc.ineqs$l(-conc.ineqs$c2))*cdf(qu)

    if(qu < ep.l){

      if(lambda.signs=="mixed"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[2] <- conc.ineqs$int.h2.explogx(max(qu,0),ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[2] <- conc.ineqs$int.h2.expx(qu,ep.l,qu,a.l,b.l)
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(ep.l, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((qu >= ep.l) & (qu < ep.r)){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(ep.r,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(ep.r,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(ep.r,0,qu,a.r,b.r)
      }

      #upper.components[3] <- boole(qu,t.cdf$x, conc.ineqs$h2(qu,t.cdf$x)*t.cdf$y) #Boole integral from qu to t.cdf$x[n]
      upper.components[3] <- GaussQuadCDF(qu, ep.r, F, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from qu to t.cdf$x[n]

    }

    if(qu >= ep.r){

      if(lambda.signs=="mixed"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu)
        upper.components[5] <- -conc.ineqs$int.h2.expx(qu,Inf,qu,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        upper.components[4] <- conc.ineqs$int.h2.const(qu,Inf,qu) # This integrates out to infinity because we need to account for the constant plateau of the NSD density above 0
        upper.components[5] <- -conc.ineqs$int.h2.explognegx(qu,0,qu,a.r,b.r)
      }

    }

    if(lower.tail){
      upper.bound <- sum(upper.components)
    }else{
      upper.bound <- sum(1,-upper.components[1:4])-upper.components[5]
    }


    ### Compute Lower Bound

    lower.components[1] <- (1-conc.ineqs$u(-conc.ineqs$c1))*cdf(ql)

    if(ql > ep.r){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql,ql,a.r,b.r)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql)
        lower.components[5] <- -conc.ineqs$int.h1.expx(ep.r,ql,ql,a.r,b.r)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
        lower.components[4] <- conc.ineqs$int.h1.const(ep.r,ql,ql) # This integrates out to ql instead of min(ql,0) because we need to account for the constant plateau of the NSD density above 0
        lower.components[5] <- -conc.ineqs$int.h1.explognegx(ep.r,min(0,ql),ql,a.r,b.r)
      }

      #lower.components[3] <- boole(ep.l,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ep.r, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to t.cdf$x[n]

    }

    if((ql > ep.l) & (ql <= ep.r)){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ep.l,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ep.l,ql,a.l,b.l)
      }

      #lower.components[3] <- boole(ql,t.cdf$x, conc.ineqs$h1(ql,t.cdf$x)*t.cdf$y,int.to.right = F) #Boole integral from ep.l to t.cdf$x[n]
      lower.components[3] <- GaussQuadCDF(ep.l, ql, T, cdf, ql, qu, conc.ineqs) #Gauss Quad integral from ep.l to ql
    }

    if(ql <= ep.l){

      if(lambda.signs=="mixed"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql,ql,a.l,b.l)
      }
      if(lambda.signs=="pos"){
        lower.components[2] <- conc.ineqs$int.h1.explogx(0,ql,ql,a.l,b.l)
      }
      if(lambda.signs=="neg"){
        lower.components[2] <- conc.ineqs$int.h1.expx(-Inf,ql,ql,a.l,b.l)
      }

    }

    if(lower.tail){
      lower.bound <- sum(lower.components)
    }else{
      lower.bound <- sum(1,-lower.components[1:4])-lower.components[5]
    }

    # Use these print functions here for debugging contributions from different components
    #print(c(qu,upper.components))
    #print(c(ql,lower.components))

    # Make sure the results fall within [0,1]

    if(lower.bound < 0){lower.bound <- 0}
    if(lower.bound > 1){lower.bound <- 1}

    if(upper.bound < 0){upper.bound <- 0}
    if(upper.bound > 1){upper.bound <- 1}


    if(log.p){
      ans <- log(c(lower.bound,upper.bound))
    }else{
      ans <- c(lower.bound,upper.bound)
    }
    ans
  }

  # Return vectorized version of bounding function
  Vectorize(cdf.bounds,vectorize.args = c("ql","qu"))
}



